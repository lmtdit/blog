## 问题

当下如何拥抱ES6的模块化机制？
当下，即2015年4月19日，眼望着ES6标准就要破土而出了，公司产品升级，同时希望针对前端问题做一次整体排查。继而同事们就AMD（requirejs）/CMD（seajs）规范各抒己见，不过最终，当我们决定选择遵循CMD规范进行前端模块化整改的时候，不幸发生了，就在昨日，玉伯兄在GITHUB上seajs issues define中的this问题 · Issue #1484 · seajs/seajs · GitHubCMD规范所谓的“通用”模块定义的“通用”为何意？ · Issue #1486 · seajs/seajs · GitHub 里强调，当下他推荐直接拥抱CommonJS 。
顿感无措，还望高瞻远瞩的各位同僚不吝赐教。

## 回答

不管AMD还是CMD，最初的目的就是为了解决多人并行开发时的团队协作问题，它们都是从commonJS分化出来的，针对浏览器端的js模块化实现规范，因此都继承了commonJS定义好的define和require这两个全局接口。

但是两个规范都会带来一些新问题，最典型的是: js模块碎片化了，是好管理了，但这会让连接数飙升，所以用于生产端前，都必须把模块按某种规则合并压缩好，但合并一起又会延伸出新的问题，比如模块间相互依赖时先后combo顺序和执行顺序，是把所有模块都combo成一个文件呢，还是分成几份，如何分？这些一系列问题处理不好就是个个坑。。。

此外，一个个define的闭包带来的性能优化问题 ，在PC端可能不是问题，但在移动端就要好好斟酌。。。

当然，即便ES6有了原生的模块化方案，在实际生产开发中，这些问题依然是存在的，也都是前端团队开发必须解决的痛点。ES6只是多了一种可能是更加优化的选择而已，当然多一个选择终归是件好事。。。或许，它会延伸出新的解决方案，探索中。。。

ok，回到原来的ES6这个话题。即便我们可以从性能上，评估得出ES6更优化，但很多在线上跑的项目，直接从切换到ES6版本这也是不现实的，估计也不会有多少团队敢这么操作，至少我不允许这么做，因为可能有很多不可控的因素，ES6要用于实际生产还需要从一些全新项目开始，从零开始允许重新规划前端开发架构的项目上使用或探索，而暂时不会应用在已有的项目上，最重要的原因就是风险和收益不成正比。

我们现在的做法还是以ES5为主，开发环境按AMD规范走，但生产时把AMD外壳剥离，自动化构建成原生的，也可以封装为commonJS的，和AMD木有关系，AMD纯粹只是方便开发和管理，因为它对于开发者而言，相对简单些。

最新、最先进的规范未必是最好的，不同团队的能力模型不一样，也要采用不同的策略，套一句广告词 —— 适合的，才是最好的。

===============补充的

刚刚看了篇2年前@左耳朵耗子的专访，有一句话，我觉得非常适合：“技术的发展要根植于历史，而不是未来。” 对此我是颇为认同的，对于js模块化的方案，现有的解决方案已经能够很好滴满足了需求，那么即便是新方案在某种个方面可能更佳，但它如果没有一个能革命性的颠覆性的效果，那么它估计推广起来依然是困难重重的。
ES6。至少我还看不到它能火的理由，谈拥抱，还为期尚早。